// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.1
// source: gleam.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	GleamMaster_GetResources_FullMethodName            = "/pb.GleamMaster/GetResources"
	GleamMaster_SendHeartbeat_FullMethodName           = "/pb.GleamMaster/SendHeartbeat"
	GleamMaster_SendFlowExecutionStatus_FullMethodName = "/pb.GleamMaster/SendFlowExecutionStatus"
)

// GleamMasterClient is the client API for GleamMaster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GleamMasterClient interface {
	GetResources(ctx context.Context, in *ComputeRequest, opts ...grpc.CallOption) (*AllocationResult, error)
	SendHeartbeat(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendHeartbeatClient, error)
	SendFlowExecutionStatus(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendFlowExecutionStatusClient, error)
}

type gleamMasterClient struct {
	cc grpc.ClientConnInterface
}

func NewGleamMasterClient(cc grpc.ClientConnInterface) GleamMasterClient {
	return &gleamMasterClient{cc}
}

func (c *gleamMasterClient) GetResources(ctx context.Context, in *ComputeRequest, opts ...grpc.CallOption) (*AllocationResult, error) {
	out := new(AllocationResult)
	err := c.cc.Invoke(ctx, GleamMaster_GetResources_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gleamMasterClient) SendHeartbeat(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &GleamMaster_ServiceDesc.Streams[0], GleamMaster_SendHeartbeat_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamMasterSendHeartbeatClient{stream}
	return x, nil
}

type GleamMaster_SendHeartbeatClient interface {
	Send(*Heartbeat) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type gleamMasterSendHeartbeatClient struct {
	grpc.ClientStream
}

func (x *gleamMasterSendHeartbeatClient) Send(m *Heartbeat) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamMasterSendHeartbeatClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gleamMasterClient) SendFlowExecutionStatus(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendFlowExecutionStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &GleamMaster_ServiceDesc.Streams[1], GleamMaster_SendFlowExecutionStatus_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamMasterSendFlowExecutionStatusClient{stream}
	return x, nil
}

type GleamMaster_SendFlowExecutionStatusClient interface {
	Send(*FlowExecutionStatus) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type gleamMasterSendFlowExecutionStatusClient struct {
	grpc.ClientStream
}

func (x *gleamMasterSendFlowExecutionStatusClient) Send(m *FlowExecutionStatus) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamMasterSendFlowExecutionStatusClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GleamMasterServer is the server API for GleamMaster service.
// All implementations must embed UnimplementedGleamMasterServer
// for forward compatibility
type GleamMasterServer interface {
	GetResources(context.Context, *ComputeRequest) (*AllocationResult, error)
	SendHeartbeat(GleamMaster_SendHeartbeatServer) error
	SendFlowExecutionStatus(GleamMaster_SendFlowExecutionStatusServer) error
	mustEmbedUnimplementedGleamMasterServer()
}

// UnimplementedGleamMasterServer must be embedded to have forward compatible implementations.
type UnimplementedGleamMasterServer struct {
}

func (UnimplementedGleamMasterServer) GetResources(context.Context, *ComputeRequest) (*AllocationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResources not implemented")
}
func (UnimplementedGleamMasterServer) SendHeartbeat(GleamMaster_SendHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method SendHeartbeat not implemented")
}
func (UnimplementedGleamMasterServer) SendFlowExecutionStatus(GleamMaster_SendFlowExecutionStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method SendFlowExecutionStatus not implemented")
}
func (UnimplementedGleamMasterServer) mustEmbedUnimplementedGleamMasterServer() {}

// UnsafeGleamMasterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GleamMasterServer will
// result in compilation errors.
type UnsafeGleamMasterServer interface {
	mustEmbedUnimplementedGleamMasterServer()
}

func RegisterGleamMasterServer(s grpc.ServiceRegistrar, srv GleamMasterServer) {
	s.RegisterService(&GleamMaster_ServiceDesc, srv)
}

func _GleamMaster_GetResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GleamMasterServer).GetResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GleamMaster_GetResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GleamMasterServer).GetResources(ctx, req.(*ComputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GleamMaster_SendHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamMasterServer).SendHeartbeat(&gleamMasterSendHeartbeatServer{stream})
}

type GleamMaster_SendHeartbeatServer interface {
	SendAndClose(*Empty) error
	Recv() (*Heartbeat, error)
	grpc.ServerStream
}

type gleamMasterSendHeartbeatServer struct {
	grpc.ServerStream
}

func (x *gleamMasterSendHeartbeatServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamMasterSendHeartbeatServer) Recv() (*Heartbeat, error) {
	m := new(Heartbeat)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GleamMaster_SendFlowExecutionStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamMasterServer).SendFlowExecutionStatus(&gleamMasterSendFlowExecutionStatusServer{stream})
}

type GleamMaster_SendFlowExecutionStatusServer interface {
	SendAndClose(*Empty) error
	Recv() (*FlowExecutionStatus, error)
	grpc.ServerStream
}

type gleamMasterSendFlowExecutionStatusServer struct {
	grpc.ServerStream
}

func (x *gleamMasterSendFlowExecutionStatusServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamMasterSendFlowExecutionStatusServer) Recv() (*FlowExecutionStatus, error) {
	m := new(FlowExecutionStatus)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GleamMaster_ServiceDesc is the grpc.ServiceDesc for GleamMaster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GleamMaster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GleamMaster",
	HandlerType: (*GleamMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetResources",
			Handler:    _GleamMaster_GetResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendHeartbeat",
			Handler:       _GleamMaster_SendHeartbeat_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendFlowExecutionStatus",
			Handler:       _GleamMaster_SendFlowExecutionStatus_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gleam.proto",
}

const (
	GleamExecutor_CollectExecutionStatistics_FullMethodName = "/pb.GleamExecutor/CollectExecutionStatistics"
)

// GleamExecutorClient is the client API for GleamExecutor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GleamExecutorClient interface {
	CollectExecutionStatistics(ctx context.Context, opts ...grpc.CallOption) (GleamExecutor_CollectExecutionStatisticsClient, error)
}

type gleamExecutorClient struct {
	cc grpc.ClientConnInterface
}

func NewGleamExecutorClient(cc grpc.ClientConnInterface) GleamExecutorClient {
	return &gleamExecutorClient{cc}
}

func (c *gleamExecutorClient) CollectExecutionStatistics(ctx context.Context, opts ...grpc.CallOption) (GleamExecutor_CollectExecutionStatisticsClient, error) {
	stream, err := c.cc.NewStream(ctx, &GleamExecutor_ServiceDesc.Streams[0], GleamExecutor_CollectExecutionStatistics_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamExecutorCollectExecutionStatisticsClient{stream}
	return x, nil
}

type GleamExecutor_CollectExecutionStatisticsClient interface {
	Send(*ExecutionStat) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type gleamExecutorCollectExecutionStatisticsClient struct {
	grpc.ClientStream
}

func (x *gleamExecutorCollectExecutionStatisticsClient) Send(m *ExecutionStat) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamExecutorCollectExecutionStatisticsClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GleamExecutorServer is the server API for GleamExecutor service.
// All implementations must embed UnimplementedGleamExecutorServer
// for forward compatibility
type GleamExecutorServer interface {
	CollectExecutionStatistics(GleamExecutor_CollectExecutionStatisticsServer) error
	mustEmbedUnimplementedGleamExecutorServer()
}

// UnimplementedGleamExecutorServer must be embedded to have forward compatible implementations.
type UnimplementedGleamExecutorServer struct {
}

func (UnimplementedGleamExecutorServer) CollectExecutionStatistics(GleamExecutor_CollectExecutionStatisticsServer) error {
	return status.Errorf(codes.Unimplemented, "method CollectExecutionStatistics not implemented")
}
func (UnimplementedGleamExecutorServer) mustEmbedUnimplementedGleamExecutorServer() {}

// UnsafeGleamExecutorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GleamExecutorServer will
// result in compilation errors.
type UnsafeGleamExecutorServer interface {
	mustEmbedUnimplementedGleamExecutorServer()
}

func RegisterGleamExecutorServer(s grpc.ServiceRegistrar, srv GleamExecutorServer) {
	s.RegisterService(&GleamExecutor_ServiceDesc, srv)
}

func _GleamExecutor_CollectExecutionStatistics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamExecutorServer).CollectExecutionStatistics(&gleamExecutorCollectExecutionStatisticsServer{stream})
}

type GleamExecutor_CollectExecutionStatisticsServer interface {
	SendAndClose(*Empty) error
	Recv() (*ExecutionStat, error)
	grpc.ServerStream
}

type gleamExecutorCollectExecutionStatisticsServer struct {
	grpc.ServerStream
}

func (x *gleamExecutorCollectExecutionStatisticsServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamExecutorCollectExecutionStatisticsServer) Recv() (*ExecutionStat, error) {
	m := new(ExecutionStat)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GleamExecutor_ServiceDesc is the grpc.ServiceDesc for GleamExecutor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GleamExecutor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GleamExecutor",
	HandlerType: (*GleamExecutorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CollectExecutionStatistics",
			Handler:       _GleamExecutor_CollectExecutionStatistics_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gleam.proto",
}

const (
	GleamAgent_SendFileResource_FullMethodName           = "/pb.GleamAgent/SendFileResource"
	GleamAgent_Execute_FullMethodName                    = "/pb.GleamAgent/Execute"
	GleamAgent_CollectExecutionStatistics_FullMethodName = "/pb.GleamAgent/CollectExecutionStatistics"
	GleamAgent_Delete_FullMethodName                     = "/pb.GleamAgent/Delete"
	GleamAgent_Cleanup_FullMethodName                    = "/pb.GleamAgent/Cleanup"
)

// GleamAgentClient is the client API for GleamAgent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GleamAgentClient interface {
	SendFileResource(ctx context.Context, opts ...grpc.CallOption) (GleamAgent_SendFileResourceClient, error)
	Execute(ctx context.Context, in *ExecutionRequest, opts ...grpc.CallOption) (GleamAgent_ExecuteClient, error)
	// collect execution stats from "gleam execute" processes
	CollectExecutionStatistics(ctx context.Context, opts ...grpc.CallOption) (GleamAgent_CollectExecutionStatisticsClient, error)
	Delete(ctx context.Context, in *DeleteDatasetShardRequest, opts ...grpc.CallOption) (*DeleteDatasetShardResponse, error)
	Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error)
}

type gleamAgentClient struct {
	cc grpc.ClientConnInterface
}

func NewGleamAgentClient(cc grpc.ClientConnInterface) GleamAgentClient {
	return &gleamAgentClient{cc}
}

func (c *gleamAgentClient) SendFileResource(ctx context.Context, opts ...grpc.CallOption) (GleamAgent_SendFileResourceClient, error) {
	stream, err := c.cc.NewStream(ctx, &GleamAgent_ServiceDesc.Streams[0], GleamAgent_SendFileResource_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamAgentSendFileResourceClient{stream}
	return x, nil
}

type GleamAgent_SendFileResourceClient interface {
	Send(*FileResourceRequest) error
	Recv() (*FileResourceResponse, error)
	grpc.ClientStream
}

type gleamAgentSendFileResourceClient struct {
	grpc.ClientStream
}

func (x *gleamAgentSendFileResourceClient) Send(m *FileResourceRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamAgentSendFileResourceClient) Recv() (*FileResourceResponse, error) {
	m := new(FileResourceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gleamAgentClient) Execute(ctx context.Context, in *ExecutionRequest, opts ...grpc.CallOption) (GleamAgent_ExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &GleamAgent_ServiceDesc.Streams[1], GleamAgent_Execute_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamAgentExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GleamAgent_ExecuteClient interface {
	Recv() (*ExecutionResponse, error)
	grpc.ClientStream
}

type gleamAgentExecuteClient struct {
	grpc.ClientStream
}

func (x *gleamAgentExecuteClient) Recv() (*ExecutionResponse, error) {
	m := new(ExecutionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gleamAgentClient) CollectExecutionStatistics(ctx context.Context, opts ...grpc.CallOption) (GleamAgent_CollectExecutionStatisticsClient, error) {
	stream, err := c.cc.NewStream(ctx, &GleamAgent_ServiceDesc.Streams[2], GleamAgent_CollectExecutionStatistics_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamAgentCollectExecutionStatisticsClient{stream}
	return x, nil
}

type GleamAgent_CollectExecutionStatisticsClient interface {
	Send(*ExecutionStat) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type gleamAgentCollectExecutionStatisticsClient struct {
	grpc.ClientStream
}

func (x *gleamAgentCollectExecutionStatisticsClient) Send(m *ExecutionStat) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamAgentCollectExecutionStatisticsClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gleamAgentClient) Delete(ctx context.Context, in *DeleteDatasetShardRequest, opts ...grpc.CallOption) (*DeleteDatasetShardResponse, error) {
	out := new(DeleteDatasetShardResponse)
	err := c.cc.Invoke(ctx, GleamAgent_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gleamAgentClient) Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error) {
	out := new(CleanupResponse)
	err := c.cc.Invoke(ctx, GleamAgent_Cleanup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GleamAgentServer is the server API for GleamAgent service.
// All implementations must embed UnimplementedGleamAgentServer
// for forward compatibility
type GleamAgentServer interface {
	SendFileResource(GleamAgent_SendFileResourceServer) error
	Execute(*ExecutionRequest, GleamAgent_ExecuteServer) error
	// collect execution stats from "gleam execute" processes
	CollectExecutionStatistics(GleamAgent_CollectExecutionStatisticsServer) error
	Delete(context.Context, *DeleteDatasetShardRequest) (*DeleteDatasetShardResponse, error)
	Cleanup(context.Context, *CleanupRequest) (*CleanupResponse, error)
	mustEmbedUnimplementedGleamAgentServer()
}

// UnimplementedGleamAgentServer must be embedded to have forward compatible implementations.
type UnimplementedGleamAgentServer struct {
}

func (UnimplementedGleamAgentServer) SendFileResource(GleamAgent_SendFileResourceServer) error {
	return status.Errorf(codes.Unimplemented, "method SendFileResource not implemented")
}
func (UnimplementedGleamAgentServer) Execute(*ExecutionRequest, GleamAgent_ExecuteServer) error {
	return status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedGleamAgentServer) CollectExecutionStatistics(GleamAgent_CollectExecutionStatisticsServer) error {
	return status.Errorf(codes.Unimplemented, "method CollectExecutionStatistics not implemented")
}
func (UnimplementedGleamAgentServer) Delete(context.Context, *DeleteDatasetShardRequest) (*DeleteDatasetShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGleamAgentServer) Cleanup(context.Context, *CleanupRequest) (*CleanupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedGleamAgentServer) mustEmbedUnimplementedGleamAgentServer() {}

// UnsafeGleamAgentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GleamAgentServer will
// result in compilation errors.
type UnsafeGleamAgentServer interface {
	mustEmbedUnimplementedGleamAgentServer()
}

func RegisterGleamAgentServer(s grpc.ServiceRegistrar, srv GleamAgentServer) {
	s.RegisterService(&GleamAgent_ServiceDesc, srv)
}

func _GleamAgent_SendFileResource_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamAgentServer).SendFileResource(&gleamAgentSendFileResourceServer{stream})
}

type GleamAgent_SendFileResourceServer interface {
	Send(*FileResourceResponse) error
	Recv() (*FileResourceRequest, error)
	grpc.ServerStream
}

type gleamAgentSendFileResourceServer struct {
	grpc.ServerStream
}

func (x *gleamAgentSendFileResourceServer) Send(m *FileResourceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamAgentSendFileResourceServer) Recv() (*FileResourceRequest, error) {
	m := new(FileResourceRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GleamAgent_Execute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecutionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GleamAgentServer).Execute(m, &gleamAgentExecuteServer{stream})
}

type GleamAgent_ExecuteServer interface {
	Send(*ExecutionResponse) error
	grpc.ServerStream
}

type gleamAgentExecuteServer struct {
	grpc.ServerStream
}

func (x *gleamAgentExecuteServer) Send(m *ExecutionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _GleamAgent_CollectExecutionStatistics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamAgentServer).CollectExecutionStatistics(&gleamAgentCollectExecutionStatisticsServer{stream})
}

type GleamAgent_CollectExecutionStatisticsServer interface {
	SendAndClose(*Empty) error
	Recv() (*ExecutionStat, error)
	grpc.ServerStream
}

type gleamAgentCollectExecutionStatisticsServer struct {
	grpc.ServerStream
}

func (x *gleamAgentCollectExecutionStatisticsServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamAgentCollectExecutionStatisticsServer) Recv() (*ExecutionStat, error) {
	m := new(ExecutionStat)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GleamAgent_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDatasetShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GleamAgentServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GleamAgent_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GleamAgentServer).Delete(ctx, req.(*DeleteDatasetShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GleamAgent_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GleamAgentServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GleamAgent_Cleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GleamAgentServer).Cleanup(ctx, req.(*CleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GleamAgent_ServiceDesc is the grpc.ServiceDesc for GleamAgent service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GleamAgent_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GleamAgent",
	HandlerType: (*GleamAgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _GleamAgent_Delete_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _GleamAgent_Cleanup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendFileResource",
			Handler:       _GleamAgent_SendFileResource_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Execute",
			Handler:       _GleamAgent_Execute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CollectExecutionStatistics",
			Handler:       _GleamAgent_CollectExecutionStatistics_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gleam.proto",
}
